import path from 'path';
import fs from "./vsfs";
import ts from 'typescript';
import {TestingFrameworks} from '../main.consts';
import {
  askQuestion,
  exitWithError,
  getCIFlag,
  getGenerateAllFilesFlag,
  getYesOrNoAnswer,
  installPackage,
  isVsCode,
  promptUserInput
} from './utils';
import {execSync} from 'child_process';
import {Color} from './Color';
import {Files} from "./Files";
export const anchor = fs.anchor;
import console, {Log} from './Log';
export const logAnchor = console.anchor
const devConfig: string = 'deepunit.dev.config.json';
const ciConfig: string = 'deepunit.ci.config.json';
const userConfig: string = 'deepunit.config.json';

// HARDCODED CONFIG VALUES
const configFilePaths = [devConfig, userConfig]; // in order of importance
const prodBase = 'https://dumper.adaptable.app';
const localHostBase = 'http://localhost:8080';
export type ConfigFieldTypes = 'string' | 'boolean' | 'array'
export type ConfigField = { name: string, description: string; value?: any, defaultValue?: any; type: ConfigFieldTypes, validator?: RegExp, required: boolean, options?: string[] }
export const userConfigurableFields: ConfigField[] = [
  { name: 'frontendFramework', description: 'If you use a frontend framework please enter the name or press enter to leave this field blank', type: 'string', required: false},
  { name: 'testSuffix', description: 'Please enter your test suffix, usually this is spec or test. Do not include the file extension', type: 'string' , validator: /^[^\\.\\\'\\"]*$/, required: true},
  { name: 'testingFramework', description: 'Please enter your testing framework, usually this is jest or jasmine', type: 'string', required: true},
  { name: 'ignoredDirectories', description: 'Please list any directory you do not want tested, this should includes any autogenerated code or dependencies', defaultValue: '["node_modules", "dist"]', type: 'array', required: false},
  { name: 'ignoredFiles', description: 'Please list any files you would like DeepUnit to ignore', type: 'array', required: false, defaultValue: '["main.ts", "app.module.ts"]'},
  { name: 'includeFailingTests', description: 'When DeepUnit runs autonomously should it include tests that fail?', type: 'boolean', required: true},
  { name: 'defaultBranch', description: 'What is this repositories default branch? Usually this is master, main or dev', type: 'string', required: true},
  { name: 'testCaseGoal', description: 'Specify the type/goal of testcases you want to cover. Examples are happy path, edgecase, 80% code coverage, detect bugs, etc', type: 'string', required: false},
  { name: 'useOpenAI', description: 'Would you like DeepUnit to use OpenAI or Open Source Models on Anyscale?', type: 'boolean', required: true, options: ["OpenAI", "Open Source with Anyscale"]},
  { name: 'testingLanguageOverride', description: 'If DeepUnit detects the testing language wrong you may set the testingLanguageOverride to "javascript" or "typescript". You may skip this field to have DeepUnit autodetect this based on your package.json', type: 'string', required: false, validator: /^(javascript|typescript)?$/},
];

async function promptVSCodeForConfig(config: ConfigField, vscode: any): Promise<ConfigField> {
  if (config.type === 'boolean' || (config.type === 'string' && config.options && config.options.length > 0)) {
    // Use showQuickPick for boolean or string fields with options
    const quickPickOptions = {
      title: config.description,
      ignoreFocusOut: true,
      canPickMany: false, // Adjust based on whether multiple selections should be allowed
    };
    
    const items = config.type === 'boolean' ? ['true', 'false'] : config.options;
    const selected = await vscode.window.showQuickPick(items, quickPickOptions);
    
    if (selected) {
      vscode.window.showInformationMessage(`Your selection: ${selected}`);
      if(config.type === 'boolean') {
        config.value = selected.toLowerCase() === 'true' ? true : false;
      } else if (config.type === 'string') {
        config.value = selected;
      }
      return config;
    } else if (config.required) {
      vscode.window.showInformationMessage('This field is required. Please make a selection. call this function again if it doesnt automatically keep the field open');
    }
  } else {
    const options = {
      prompt: config.description, // The prompt text to display
      placeHolder: config.defaultValue ? config.defaultValue : "", // Placeholder in the input field to show an example or hint
      ignoreFocusOut: true, // Set to true to keep the input box open even when losing focus
      validateInput: (text: string) => {
        if (config.required && !text) {
          return `This field is required. Please enter a value.\n${config.description}`;
        }
        if(config.type==='array') {
          if(!text.startsWith('[')) {
            return `Your entry must begin with [. Validation code: text.startsWith('[')`
          }
          if(!text.endsWith(']')) {
            return `Your entry must end with ]. Validation code: text.endsWith(']')`
          }
        }
        if (config.validator) {
          return config.validator.test(text) ? null : `Please enter a valid value. Validation regex: ${config.validator}`
        }
        return null;
      }
    };
    const value = await vscode.window.showInputBox(options)
      // value is the user input as a string or undefined
      if (value) {
        vscode.window.showInformationMessage(`Your entry: ${value}`);
        if(config.type ==='string') {
          config.value = value;
        } else if(config.type === 'array') {
          config.value = value;
        } else {
          config.value = value
        }
        return config;
      } else {
        vscode.window.showInformationMessage('Nothing entered.');
        if(config.type ==='string') {
          config.value = '';
        } else if(config.type === 'array') {
          config.value = [];
        }
        return config;
      }
  }
}
async function promptCLIForConfig(config: ConfigField): Promise<ConfigField> {
  if (config.type === 'string') {
    const answer = await promptUserInput(config.description + ': ', '');
    config.value = answer;
  } else if (config.type === 'boolean') {
    const answer = await getYesOrNoAnswer(config.description)
    const answerString = answer
    config.value = answerString
  } else if (config.type === 'array') {
    const answer = await promptUserInput(config.description + '. Please enter in the format of an array of strings, for example: ["node_modules"]. Enter array here: ', '')
    if(answer.length<2) {
      config.value = '[]'
    } else if(!answer.trim().startsWith('[')) {
      const splitted = answer.trim().split(',')
      config.value = splitted
    } else {
      config.value = answer;
    }
    config.value = answer;
  } else {
    exitWithError('An impossible error has occured!')
  }
  return config;
}
function buildConfigJsonFromArray(configs: ConfigField[]): string {
  const configObject = configs.reduce((acc, config) => {
    // Use config.name as the key and config.value as the value
    // Assuming config.value is already in the desired format (string, boolean, etc.)
    // If config.value is a string that represents an array or object, it might need parsing or further handling based on context
    acc[config.name] = config.value;
    return acc;
  }, {});
  
  // Convert the config object to a JSON string with indentation for readability
  return JSON.stringify(configObject, null, 2);
}
export async function checkAndCreateConfig() {
  if (getCIFlag()) {
    const exampleConfig =
      '{\n' +
      '  "documentation": "You can find documentation on these configs at https://www.npmjs.com/package/deepunit",\n' +
      '  "frontendFramework": "",\n' +
      '  "testingFramework": "",\n' +
      '  "ignoredDirectories": ["node_modules"],\n' +
      '  "ignoredFiles": [],\n' +
      '  "includeFailingTests": true,\n' +
      '  "testSuffix": "",\n' +
      '  "testingLanguageOverride": "",\n' +
      '  "defaultBranch": "master",\n' +
      '  "testCaseGoal": "",\n' +
      '  "useOpenAI": true\n' +
      '}\n';
    if (!fs.existsSync(ciConfig)) {
      console.log(exampleConfig)
      exitWithError('You must configure a deepunit.ci.config.json. You may reference our documentation at https://www.npmjs.com/package/deepunit or reach out to support@deepunit.ai for assistance. See the example config printed above.')
    } else {
      return
    }
  }
  if (!fs.existsSync(userConfig)) {
    const isVSCode = isVsCode();
    let vscode;
    if (isVSCode) {
      vscode = require('vscode')
      vscode.window.showQuickPick()
    }
    let finalConfig: ConfigField[] = [{ description: '', type: 'string', required: true, value:'You can find documentation on these configs at https://www.npmjs.com/package/deepunit', name:'documentation'}];
    for (let i = 0; i<userConfigurableFields.length; i++) {
      const config = userConfigurableFields[i]

      if (isVSCode) {
        let userConfigValue = await promptVSCodeForConfig(config, vscode)
        finalConfig.push(userConfigValue)
      } else {
        const userConfigValue = await promptCLIForConfig(config)
        finalConfig.push(userConfigValue)
      }
    }
    const configJson = buildConfigJsonFromArray(finalConfig);
    fs.writeFileSync(userConfig, configJson, 'utf-8')
  }
  const config = new Config()
  return config;
}

/** Automatically Detected Project configs
 * These configs are first pulled from deepunit.config.json, if absent we will try to use the detect*() Function to autodetect
 */
export default class Config {
  frontendFramework: string = 'angular';
  frameworkVersion: string = '';
  testSuffix: string = '';
  testingFramework: TestingFrameworks = TestingFrameworks.unknown;
  scriptTarget: string = '';
  doProd: boolean;
  apiHost: string = '';
  ignoredDirectories: string[] = [];
  ignoredFiles: string[] = [];
  includeFailingTests: boolean = true;
  generateAllFiles: boolean;
  isDevBuild: boolean = false;
  prodTesting: boolean = false;
  testingLanguageOverride: string = '';
  testingFrameworkOverride: string = '';
  isGitRepository: boolean = false;
  private readonly undefinedVersion = '-1';
  private versionCache: string = this.undefinedVersion;
  platform: string = '';
  defaultBranch: string = ''
  testCaseGoal: string = '';
  useOpenAI: boolean = false;
  
  public constructor() {
    this.detectProjectType();
    this.determineDevBuild();
    this.testSuffix = this.detectTestSuffix();
    this.testingFramework = this.getTestFramework();
    this.frameworkVersion = this.getFrameworkVersion();
    this.testingFrameworkOverride = Config.getStringFromConfig('testingFramework').toLowerCase();
    if (this.testingFrameworkOverride && (Object.values(TestingFrameworks) as string[]).includes(this.testingFrameworkOverride)) {
      this.testingFramework = this.testingFrameworkOverride as TestingFrameworks;
    } else if (!fs.existsSync(userConfig) && this.testingFramework === undefined) {
      //if the framework is undefined and the user config does exist then we will set to jasmine
      //the reason for this is there is currently a bug where any unit test with a dependency on API.ts will cause main.ts to be executed because Api imports AUTH from main. This results in JestTester.test.ts instanciating Jasmine tester which causes errors. It would be niice to fix this, but sort of a pain
      this.testingFramework = TestingFrameworks.jasmine
    }
  
    this.scriptTarget = this.getsConfigTarget() ?? 'unknown';
    this.prodTesting = Config.getBoolFromConfig('prodTesting');
    this.doProd = Config.getBoolFromConfig('doProd', true);
    this.ignoredDirectories = Config.getArrayFromConfig('ignoredDirectories');
    this.ignoredFiles = Config.getArrayFromConfig('ignoredFiles');
    this.apiHost = this.doProd ? prodBase : localHostBase;
    this.includeFailingTests = Config.getBoolFromConfig('includeFailingTests', true);
    this.generateAllFiles = getGenerateAllFilesFlag();
    this.testingLanguageOverride = Config.getStringFromConfig('testingLanguageOverride');
    this.isGitRepository = this.isInGitRepo();
    this.platform = process.platform;
    this.defaultBranch = Config.getStringFromConfig('defaultBranch')
    this.testCaseGoal = Config.getStringFromConfig('testCaseGoal')
    this.useOpenAI = Config.getBoolFromConfig('useOpenAI', true);
  }

  /**
   * Get an boolean value from config (default to false, if the value is not exactly true, we also return false)
   */
  private static getBoolFromConfig(configProperty: string, defaultVal = false): boolean {
    const configVal = Config.getValueFromConfigFile(configProperty);
    return typeof configVal === 'boolean' ? configVal : defaultVal;
  }

  public async getVersion(): Promise<string> {
    if (this.versionCache !== this.undefinedVersion) {
      return this.versionCache;
    }
    const packageJson = require('../../package.json');
    const version = packageJson?.version;
    if (version) {
      this.versionCache = version;
      return this.versionCache;
    } else {
      await exitWithError('Unable to detect DeepUnit version, this should never happen.'); //should never happen but in case
      return '';
    }
  }

  private getFrameworkVersion(): string {
    let frameworkVersion = this.getPackageVersionIfInstalled(this.frontendFramework);
    if(frameworkVersion) {
      return frameworkVersion;
    } else {
      return '';
    }

  }

  private getLanguage(): string {
    if (this.testingLanguageOverride) {
      return this.testingLanguageOverride;
    }
    let fileContent = fs.readFileSync('package.json', 'utf8');
    if (!fileContent.includes('typescript')) {
      return 'javascript';
    }

    return 'typescript';
  }

  private isInGitRepo(): boolean {
    try {
      execSync('git rev-parse --is-inside-work-tree', { stdio: 'pipe' });
      return true;
    } catch (error: any) {
      if (error.message && typeof error.message === 'string' && error.message.includes('not a git repository')) {
        return false;
      }
      throw error; // If the error is something else, we might want to rethrow it.
    }
  }

  private detectProjectType(): void {
    const configValue = Config.getStringFromConfig('frontendFramework');
    if (configValue) {
      this.frontendFramework = configValue;
      return;
    }
    let angularJsonPath = 'angular.json';
    let packageJsonPath = 'package.json';

    if (fs.existsSync(angularJsonPath)) {
      this.frontendFramework = 'angular';
      return;
    } else if (fs.existsSync(packageJsonPath)) {
      let packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
      let dependencies = packageJson['dependencies'] || {};
      let devDependencies = packageJson['devDependencies'] || {};
      if ('angular/common' in dependencies || 'angular/common' in devDependencies) {
        this.frontendFramework = 'angular';
        return;
      }
      if ('react' in dependencies || 'react' in devDependencies) {
        this.frontendFramework = 'react';
        return;
      }
    }
    this.frontendFramework = '';
  }

  private determineDevBuild() {
    if (fs.existsSync(devConfig) && !this.prodTesting) {
      this.isDevBuild = true;
    } else if (fs.existsSync(devConfig) && this.prodTesting) {
      console.log('DeepUnit is running in production testing mode');
    }
  }

  private getTestFramework(): TestingFrameworks {
    let jestConfigPath = 'jest.config.js';
    let karmaConfigPath = 'karma.conf.js';
    let packageJsonPath = 'package.json';
    let testingFramework = TestingFrameworks.unknown;
    if (fs.existsSync(jestConfigPath)) {
      testingFramework = TestingFrameworks.jest;
    } else if (fs.existsSync(karmaConfigPath)) {
      testingFramework = TestingFrameworks.jasmine;
    } else if (fs.existsSync(packageJsonPath)) {
      let fileContent = fs.readFileSync(packageJsonPath, 'utf8');
      if (fileContent.includes('jest')) {
        testingFramework = TestingFrameworks.jest;
      } else if (fileContent.includes('jasmine-core')) {
        testingFramework = TestingFrameworks.jasmine;
      }
    }

    return testingFramework;
  }

  private detectTestSuffix(): string {
    let testSuffix = Config.getStringFromConfig('testSuffix');
    if (!testSuffix) {
      testSuffix = 'spec';
    }
    return testSuffix;
  }

  private getsConfigTarget(): string | undefined {
    let tsconfigPath: string | undefined = 'tsconfig.json';

    while (tsconfigPath) {
      if (fs.existsSync(tsconfigPath)) {
        let contents: string = fs.readFileSync(tsconfigPath, 'utf8');
        try {
          let tsconfigJson = ts.parseConfigFileTextToJson('', contents);
          const scriptTarget = tsconfigJson.config?.compilerOptions?.target;
          if (scriptTarget) {
            return scriptTarget;
          }
          if (tsconfigPath != null) {
            // @ts-ignore
            tsconfigPath = tsconfigJson.config?.extends ? path.join(path.dirname(tsconfigPath), tsconfigJson.config?.extends) : null;
          }
        } catch (error) {
          console.error(error);
          // TODO: we need to make this async but can't because it is within the constructor
          exitWithError('Unable to read the tsconfig');
        }
      } else {
        tsconfigPath = undefined;
      }
    }
  }

  /**
   * Get an array value from config (supports all sub-types of array)
   */
  public static getArrayFromConfig(configProperty: string): string[] {
    const configVal = Config.getValueFromConfigFile(configProperty);
    if (configVal && Array.isArray(configVal)) {
      return configVal;
    }

    return [];
  }
  
  /**
   * Get an string value from config (even if the value is something else, we convert to string)
   */
  public static getStringFromConfig(configProperty: string, defaultValue?: string): string {
    const configVal = Config.getValueFromConfigFile(configProperty);
    if (configVal) {
      return configVal.toString();
    } else if(defaultValue) {
      return defaultValue
    }

    return '';
  }

  /**
   * HELPER FUNCTION: Get the json value from config
   * If the CI flag was used it will use the ciConfig, otherwise it will use the dev config and user config
   */
  private static getValueFromConfigFile(configProperty: string): unknown {
    let configPaths: string[] = getCIFlag() ? [ciConfig] : configFilePaths
    for (let configPath of configPaths) {
      if (fs.existsSync(configPath)) {
        let config = JSON.parse(fs.readFileSync(configPath, 'utf8'));

        if (configProperty in config) {
          let configValue = config[configProperty];
          return configValue;
        }
      }
    }
  }

  public async confirmAllPackagesNeeded() {
    await this.confirmJestExists();
    if (this.frontendFramework == 'react') {

      await this.confirmReactPackages();
    }
  }

  private async confirmJestExists() {
    // we overwrote the framework, ignore the checks
    if (this.testingLanguageOverride) {
      console.log('Using test language override of' + this.testingLanguageOverride);
      return;
    }

    let fileContent = fs.readFileSync('package.json', 'utf8');
    if (!fileContent.includes('jest')) {
      const wantsToUseJest = await getYesOrNoAnswer('Jest is not installed, would you like to install it? (it is required to generate tests)');
      if (!wantsToUseJest) {
        await exitWithError('Unable to generate tests without Jest');
      }
      // install jest
      installPackage('jest', true);
      console.log('Installing jest');

      // if typescript, then install requirements for those
      if (this.getLanguage() == 'typescript') {
        console.log('Typescript Detected: Installing typescript requirements for Jest');
        installPackage('ts-jest', true);
        installPackage('@types/jest', true);

        const jestConfig = "module.exports = {\n  preset: 'ts-jest',\n  testEnvironment: 'node',\n};";

        if (!fs.existsSync('jest.config.js')) {
          fs.writeFileSync('jest.config.js', jestConfig);
        } else {
          console.warn('Unable to create jest.config.js for typescript changes, it already exists. Ignoring...');
        }
      }
    }
  }

  private async confirmReactPackages() {



    const requiredPackaged = [
      { name: '@testing-library/react', installVersion: 'release-12.x' },
      { name: '@testing-library/react-hooks' },
      { name: 'react-router-dom', installVersion: 'classic' },
    ];

    let neededPackages = [];
    for (let requiredPackage of requiredPackaged) {
      if (!this.getPackageVersionIfInstalled(requiredPackage.name)) {
        neededPackages.push(requiredPackage);
      }
    }

    // if missing packages, request to install them
    if (neededPackages.length > 0) {
      console.log(`In order to generate unit tests for ${this.frontendFramework}, we require the following dev dependencies to be installed:\n`);
      neededPackages.forEach((p) => console.log(' - ' + p.name));
      const wantsToInstallDependencies = await getYesOrNoAnswer('Install Required Packages?');
      if (wantsToInstallDependencies) {
        const remappedPacks = neededPackages.map((p) => (p.installVersion ? `${p.name}@${p.installVersion}` : p.name));
        installPackage(remappedPacks.join(' '), true);
      } else {
        console.error(
          Color.yellow(
            'Packages are required to run tests, please install the missing packages or enable includeFailingTests in the config, so you can manage the dependencies yourself.',
          ),
        );
      }
    }
  }

  private confirmRunningReactVersion18(): boolean {
    const reactVersion = this.getPackageVersionIfInstalled('react');
    const versionRegex = new RegExp(/([\d.]+)/);
    if (!reactVersion) {
      console.warn('React is a missing dependency, yet we assume you are using react. There is an issue, please check your config that you are not forcing it to be react.');
    } else {
      const versionNumbers = reactVersion.match(versionRegex);
      if (versionNumbers && versionNumbers[0] && versionNumbers[0].split('.') && !isNaN(+versionNumbers[0].split('.')[0])) {
        const number = +versionNumbers[0].split('.')[0];
        if (number >= 18) {
          console.warn(Color.yellow('We currently do not support react version 18 and above. You may continue although imports might not work right.'));
          return true;
        }
      } else {
        console.error('Unable to parse react version number.');
      }
    }
    return false;
  }

  public getPackageVersionIfInstalled(requiredPackaged: string): string | null {
    let packageJsonPath = 'package.json';

    if (fs.existsSync(packageJsonPath)) {
      let packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
      let dependencies = packageJson['dependencies'] || {};
      let devDependencies = packageJson['devDependencies'] || {};
      if (requiredPackaged in dependencies) {
        return dependencies[requiredPackaged];
      }
      if (requiredPackaged in devDependencies) {
        return devDependencies[requiredPackaged];
      }
    }

    return null;
  }
  
  public async askForDefaultBranch() {
    if(!this.defaultBranch) {
      const branchName = await askQuestion('Please enter the name of your default branch. This is usually main, master or dev but could be anything: ', 'master')
      this.defaultBranch = branchName
      await Files.updateConfigFile('defaultBranch', branchName)
    }
  }
}
